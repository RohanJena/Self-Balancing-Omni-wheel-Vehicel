#python

###### GLOBAL VARIABLES HERE ######

U = 0.00
time = 0.01
k = [19.77525,0.70711,15.11526,3.53797]


# You can add variables here 
# as required by your implementation.
####################################

def sysCall_init():
    # do some initialization here
    # This function will be executed once when the simulation starts
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Initialize the scene objects which you will require 
    #       Initialize algorithm related variables here
    
    #################################
     
    pass

    

def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    base = sim.getObjectHandle('/Base_A')
    motor = sim.getObjectHandle('/Base_A/Motor_A')
    arm = sim.getObjectHandle('/Base_A/Motor_A/Arm_A')
    pendulum = sim.getObjectHandle('/Base_A/Motor_A/Arm_A/Elbow_A/Pendulum_A')
    elbow = sim.getObjectHandle('/Base_A/Motor_A/Arm_A/Elbow_A')
    elbow_init = 0
    motor_init = 0
    elbow_init_vel = 0
    motor_init_vel = 0
    elbow_angle = sim.getJointPosition(elbow)
    motor_angle = sim.getJointPosition(motor)
    elbow_vel = sim.getJointVelocity(elbow)
    motor_vel = sim.getJointVelocity(motor)
    
    alpha = (motor_angle - motor_init)/200.0
    theta = (elbow_angle - elbow_init)/15.0
    theta_dot = theta/(0.01)
    alpha_dot =  alpha/(0.01)               #motor_vel - motor_init_vel
    U = (k[0]*alpha_dot + k[1]*alpha + k[2]*theta_dot +k[3]*theta)
    sim.setJointTargetVelocity(motor,U)
    sim_time = sim.getSimulationTime()
    print(sim_time)

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
    pass

    
    


def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details